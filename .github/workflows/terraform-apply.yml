name: 'Terraform Apply'

on:
  push:
    branches: [ "main" ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-*.yml'

env:
  TF_VERSION: '1.5.7'
  TF_IN_AUTOMATION: true
  TF_INPUT: false

permissions:
  contents: read
  id-token: write

jobs:
  terraform-apply:
    name: 'Apply Infrastructure Changes'
    runs-on: ubuntu-latest
    environment: 
      name: dev
      url: ${{ steps.output.outputs.app_url }}
    
    outputs:
      frontend_bucket: ${{ steps.output.outputs.frontend_bucket }}
      load_balancer_ip: ${{ steps.output.outputs.load_balancer_ip }}
      
    defaults:
      run:
        shell: bash
        working-directory: terraform/environments/dev

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Terraform Init
      id: init
      run: |
        terraform init
        terraform workspace select dev || terraform workspace new dev

    - name: Terraform Plan
      id: plan
      run: |
        terraform plan -detailed-exitcode -out=tfplan
      env:
        TF_VAR_notification_email: ${{ secrets.NOTIFICATION_EMAIL }}
      continue-on-error: true

    - name: Check Plan Status
      if: steps.plan.outputs.exitcode == '1'
      run: |
        echo "❌ Terraform plan failed!"
        exit 1

    - name: Terraform Apply
      if: steps.plan.outputs.exitcode == '2'
      id: apply
      run: |
        terraform apply -auto-approve tfplan
        echo "✅ Terraform apply completed successfully!"

    - name: Capture Outputs
      id: output
      run: |
        # Capture key outputs
        FRONTEND_BUCKET=$(terraform output -raw frontend_bucket_name)
        LOAD_BALANCER_IP=$(terraform output -raw load_balancer_ip)
        DOCKER_REPO=$(terraform output -raw docker_repository_url)
        
        echo "frontend_bucket=$FRONTEND_BUCKET" >> $GITHUB_OUTPUT
        echo "load_balancer_ip=$LOAD_BALANCER_IP" >> $GITHUB_OUTPUT
        echo "docker_repo=$DOCKER_REPO" >> $GITHUB_OUTPUT
        echo "app_url=http://$LOAD_BALANCER_IP" >> $GITHUB_OUTPUT
        
        # Save outputs to file
        terraform output -json > outputs.json

    - name: Upload Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs
        path: terraform/environments/dev/outputs.json
        retention-days: 90

    - name: Update GitHub Secrets
      uses: actions/github-script@v7
      with:
        script: |
          const sodium = require('tweetsodium');
          
          async function updateSecret(secretName, secretValue) {
            // Get the repository public key
            const { data: { key, key_id } } = await github.rest.actions.getRepoPublicKey({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            // Encrypt the secret value
            const messageBytes = Buffer.from(secretValue);
            const keyBytes = Buffer.from(key, 'base64');
            const encryptedBytes = sodium.seal(messageBytes, keyBytes);
            const encryptedValue = Buffer.from(encryptedBytes).toString('base64');
            
            // Create or update the secret
            await github.rest.actions.createOrUpdateRepoSecret({
              owner: context.repo.owner,
              repo: context.repo.repo,
              secret_name: secretName,
              encrypted_value: encryptedValue,
              key_id: key_id,
            });
          }
          
          // Update secrets with Terraform outputs
          const outputs = {
            FRONTEND_BUCKET_NAME: '${{ steps.output.outputs.frontend_bucket }}',
            API_URL: 'http://${{ steps.output.outputs.load_balancer_ip }}/api'
          };
          
          for (const [key, value] of Object.entries(outputs)) {
            if (value && value !== 'null') {
              console.log(`Updating secret: ${key}`);
              await updateSecret(key, value);
            }
          }
      continue-on-error: true

    - name: Generate Summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## 🚀 Infrastructure Deployment Summary
        
        **Status:** ✅ Successfully Applied
        
        ### 📊 Key Resources
        
        | Resource | Value |
        |----------|-------|
        | **Frontend Bucket** | \`${{ steps.output.outputs.frontend_bucket }}\` |
        | **Load Balancer IP** | \`${{ steps.output.outputs.load_balancer_ip }}\` |
        | **Application URL** | [http://${{ steps.output.outputs.load_balancer_ip }}](http://${{ steps.output.outputs.load_balancer_ip }}) |
        
        ### 🔧 Next Steps
        
        1. Wait for DNS propagation (if using custom domain)
        2. Deploy applications using the build-deploy workflow
        3. Monitor the deployment in [GCP Console](https://console.cloud.google.com)
        
        ### 📝 Configuration Commands
        
        \`\`\`bash
        # Configure kubectl
        gcloud container clusters get-credentials dogfydiet-dev-gke-cluster --region us-central1
        
        # Check cluster status
        kubectl get nodes
        kubectl get pods --all-namespaces
        \`\`\`
        EOF

    - name: Notify Slack
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        text: |
          Terraform Apply ${{ job.status }}
          Environment: dev
          Actor: ${{ github.actor }}
          Commit: ${{ github.sha }}
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      continue-on-error: true

  post-deployment-tests:
    name: 'Post Deployment Tests'
    needs: terraform-apply
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Test Load Balancer
      run: |
        LB_IP="${{ needs.terraform-apply.outputs.load_balancer_ip }}"
        echo "Testing Load Balancer at: http://$LB_IP"
        
        # Wait for LB to be ready
        for i in {1..30}; do
          if curl -s -o /dev/null -w "%{http_code}" "http://$LB_IP" | grep -q "404\|200"; then
            echo "✅ Load Balancer is responding"
            break
          fi
          echo "Waiting for Load Balancer... ($i/30)"
          sleep 10
        done
    
    - name: Validate GKE Cluster
      run: |
        # Authenticate
        gcloud auth activate-service-account --key-file=<(echo '${{ secrets.GCP_SA_KEY }}' | base64 -d)
        
        # Get cluster credentials
        gcloud container clusters get-credentials dogfydiet-dev-gke-cluster \
          --region us-central1 \
          --project nahuelgabe-test
        
        # Check cluster health
        kubectl get nodes
        kubectl get namespaces
        kubectl get pods --all-namespaces